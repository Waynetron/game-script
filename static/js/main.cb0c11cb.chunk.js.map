{"version":3,"sources":["Game/images sync /^/.//.*/.png$","Game/images/brick.png","Game/images/goomba.png","Game/images/goombared.png","Game/images/no-image.png","Game/images/player.png","Game/images/questionbrick.png","Game/images/spike.png","Code/reducer.js","Game/constants.js","util/state.js","util/parse.js","Game/physics.js","Game/reducer.js","reducers.js","debug/DebugColliding.js","Game/Sprite.js","Game/Game.js","Game/Loop.js","Game/actions.js","Code/actions.js","ImagePicker/ImagePicker.js","Code/Code.js","App/App.js","App/actions.js","index.js"],"names":["map","./brick.png","./goomba.png","./goombared.png","./no-image.png","./player.png","./questionbrick.png","./spike.png","webpackContext","req","id","webpackContextResolve","__webpack_require__","e","Error","code","keys","Object","resolve","module","exports","defaultState","gameReducer","state","arguments","length","undefined","action","type","objectSpread","TOP","LEFT","RIGHT","createNewSprite","name","x","y","position","velocity","maxVelocity","acceleration","colliding","top","bottom","left","right","static","inputs","separateWords","leftAndRightString","string","replace","trimBrackets","trim","split","states","UP","DOWN","FAST_UP","FAST_DOWN","FAST_LEFT","FAST_RIGHT","SLOW_UP","SLOW_DOWN","SLOW_LEFT","SLOW_RIGHT","JUMP","DEAD","dead","STATIC","<UP>","<DOWN>","<LEFT>","<RIGHT>","<ACTION>","<ACTION1>","<ACTION2>","getCollidingForSide","side","traverseDirection","currentIndex","nextIndex","collidesWith","console","error","nextColliding","defineProperty","getColliding","direction","leftStates","leftIndex","frontSide","down","up","directionToSide","backSide","forward","getOpposite","frontColliding","backColliding","wordsToState","words","names","statesArr","word","resultState","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","Symbol","iterator","next","done","stateObj","value","merge","err","return","addNewState","sprites","newState","toConsumableArray","concat","mergeCustomizer","objValue","srcValue","isNumber","applyStateMutations","sprite","mutations","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","mutation","_mutation2","slicedToArray","matches","mergeWith","isAlive","isCreateNewState","stateMutation","createNew","isCollisionRule","line","includes","isRule","isLevel","match","isLegend","collisionExpandMappings","ALL","HORIZONTAL","VERTICAL","regularExpandMappings","parseRules","regularRules","filter","expandedRegularRules","flatten","expandedLines","_arr","entries","_i","_ref3","_ref2","key","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","expanded","push","expandRegularRule","collisionRules","_line$split3","appendedLine","_arr2","_i2","_ref6","_ref5","directions","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","expandCollisionRule","roundToPixels","Math","round","getEdges","isOverlapping","spriteA","spriteB","a","b","overlapsPoint","point","padding","_getEdges","overlapsSide","points","getPointsForSide","getCollidedEdges","prevEdgesA","prevPosition","prevEdgesB","collidedEdges","getSeparatedState","edgeA","edgesB","applySpriteCollisions","newSpriteA","storePreviousPosition","applyAcceleration","max","min","applyVelocity","resetColliding","applyFriction","legend","rules","stateMutations","width_in_tiles","height_in_tiles","active","theme","debug","imageMap","images","_sprites","_sprites2","_sprites3","_sprites4","_sprites5","_sprites6","_sprites7","_sprites8","_sprites9","_sprites10","_sprites11","_sprites12","_sprites13","_sprites14","variableName","imageName","join","removeComments","level","slice","parseLevel","forEach","_line$split$map","str","_line$split$map2","symbol","randIndex","floor","random","parseLegend","row","char","col","getName","uniqid","parseSprites","namesArr","_line$split","parseNames","reduce","obj","item","toLowerCase","_parseRules","_parseRules2","rule","ruleString","_ruleString$split3","_ref","leftWords","rightWords","ruleToStateMutation","collisionStateMutationPairs","_leftGroup$split","_rightGroup$split","_ruleString$match","_ruleString$split","_ruleString$split2","_left$match","leftGroup","_right$match","rightGroup","leftWordArrays","rightWordArrays","rightStates","leftStatesWithColliding","index","rightIndex","matchingLeft","newSprite","leftState","collisionRuleToStateMutations","collisionStateMutations","collisionStateMutationsCreate","collisionStateMutationsModify","_getLevelDimensions","getLevelDimensions","_getLevelDimensions2","width","height","stateToAdd","vectorA","vectorB","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","_mutation","getNewStateToAdd","edge","updateSpriteCollidingState","newPosition","applyWallCollisions","input","newInputs","combineReducers","codeReducer","game","DebugColliding","react_default","createElement","className","getPositionStyle","Sprite","img","style","src","require","alt","DebugColliding_DebugColliding","Game","src_Game_Sprite","connect","dispatch","onTimeChange","request","useEffect","requestAnimationFrame","advanceFrame","cancelAnimationFrame","compile","onSelect","image","Tooltip_default","interactive","title","onClick","grammar","comment","variable","pattern","RegExp","onKeyDown","event","editor","ctrlKey","preventDefault","log","addMark","getContent","token","content","decorateNode","node","others","texts","getTexts","toArray","t","text","tokens","Prism","tokenize","decorations","startText","shift","endText","startOffset","endOffset","start","newlines","end","available","remaining","dec","anchor","offset","focus","mark","onUpdateCode","Plain","serialize","onCompile","slate_react_es","defaultValue","deserialize","onChange","renderMark","props","children","attributes","_node$text$split$map","_right$split","firstName","src_ImagePicker_ImagePicker","assign","opacity","fontWeight","darkColors","primary","secondary","dark","light","lightColors","keyMap","sequence","action1","action2","cancel_up","cancel_down","cancel_left","cancel_right","cancel_action1","cancel_action2","handlers","onSetInput","onCancelInput","onReset","onRun","onToggleDebug","isGameActive","r","d","space","setGameActive","setActive","setInput","cancelInput","onToggleTheme","colors","react_custom_properties_default","properties","--primary-color","--secondary-color","--dark-color","--light-color","--hover-color","src_Code_Code","index_es","Game_Loop","src_Game_Game","persistConfig","storage","persistedReducer","persistReducer","rootReducers","store","createStore","window","__REDUX_DEVTOOLS_EXTENSION__","persistor","persistStore","ReactDOM","render","es","integration_react","loading","src_App_App","document","getElementById"],"mappings":"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","file":"static/js/main.cb0c11cb.chunk.js","sourcesContent":["var map = {\n\t\"./brick.png\": 295,\n\t\"./goomba.png\": 296,\n\t\"./goombared.png\": 297,\n\t\"./no-image.png\": 298,\n\t\"./player.png\": 299,\n\t\"./questionbrick.png\": 300,\n\t\"./spike.png\": 301\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) { // check for number or string\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn id;\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 116;","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAD5JREFUWAnt10ERADAIA7Ax87iZRXao6CcYaMmv1fPmJC9ZYLNv8vnNVoAAAQIECBAgQIAAAQIECFRyHe84/XTlDQmQUCOUAAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAYdJREFUWAntVz1LA0EQfbuEeAgi2EWsBCsL/0JqKytLf4KV+IGQIiDxxMqfYBOwECvr/AULK8FKSCeIzWlx6zzjQdibDRdwL80NhNy8zMx7O3N3YQzEUve4kePrCnBdcTvEItoYMCOLpeMTs/tmSO6QPTlgLSJpqbQB3g2Sndbk5PWSUw0P7KTr9q/tJYX1AK4rAqLPfNZZOhSwUGsENB1oOhDqwDdgTxMsr/PDa3lWBatslfNbeknbOzN76dRv6cA9iJtfTmEzLqvnqx1IkNz61TXMjyl8LVbDGK8KKArV8a0KyJAd+OQa5scUvharYYw3A3cv/4wl403UK9o2Sc77EtUuRepA5fyQAL1sBFQdQQSeYMlGQOBFJHcn7Pkmtq73zfY8b0C11Xfuuf2KlyOH/MIPCI5gBas3/0FOQtZhPZ+cflDAJz4OqVxLmhdjHdbT8prHMDgCrV0xMAqQXW1hNhYBZrQwei6p3FK5KNYtgpzktr8rsmyp0omhiKhjHMJhhtyMyf0DfCpzwbzHSMoAAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAYxJREFUWAntV0FKw1AQnT82WRQqtDvFdbdewVN06RFciRUCLiwFI648QjdCT+EV3HYtuEvRgosEE+dFAk2Y3ybgTzcZKM1M3rw3mUk+/xsS+w7DsyRJHg3RRZZlJ4i5MmPMR0b06nneTX86fTe5eBy/ieDIlaiFN/J8/5zx5AcQR00jaDPaDu8QBm12PfNdDwZt3gVo415XQNeBrgNqB2SBiA3zbY/5FD9cI1b3s2yS31NJme+OgyDcuhd+zedEafqwFbNfNshXO3BEtKiya7EqpvA1rBYDXi2gIGrjXy3gh+iyKq7FqpjC17BaDHjzOZvJ/qBs+Qsncyzalien6b0A/TJS95rkqwXotG6i6gjcSOmsXQH6QiTdkt1rMBiPn8xkUnsF1JtMlC2X/ma1upYdkKxmZbOOYDAcPv+HOOTAA76y9J9nLWCzXl+hci2paSzvgPBped1naB2B1i4XMcZZzQVxHU5oMw6KdcAuMNBmnFKFPHIhsIczgjbjiIxTqqw8L22MI9cQLWhC+xfEpII8G45emQAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAW5JREFUWAntlsFOwzAMhu1qrwMSnOAtYOLCk3SDM6IVD8IFTeMp2AleqJqxS5JtrsucCSlCai6J7dj/lyxWh8+0Iig5SgKIdlXy8KI9AUw38P9uoKH12W+dcyyuc7NuoKX1HQF9cv82upDY4pe47LPils8NIEW3QK8ANONCtYYIdi1x2eeFcAEo8XiQBLETjyE/hAuAT3QZTh4V4iwQH2zwyfWgGcH2Qnu17QJY4u0DJ7Y6OdhXI/52gfPHkVhyuwBk9xLnC57GIFLBsGjDfu0f2G4AyXRCuMWlZhaAJPz1yAIYvnYTJ3WHGVVON4BTPJZ3Q7gAGlo9cWWj1Xq9TVRVcx3ylPvQdAEgVF8A2B2m9pY8uGteGd2B3U+ekbXncgHUePNWAd4riPTah92BneyXvD0tc+kCkEwFkcRj1R2EX7zP5ceV9bf8hd7Po6g153yOe+1cAEv0VJ9ou3+CU0WO5U0A0w0UvwEs2YbSId8ezJqOYuBQ4gAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAU5JREFUWAljZCAA2v+v+09ACU5pRgbG/xWMgUw4FQAl8Eri00gtuVEHjIbAaAgMeAgwUlLQUKMsGPAQGHXAaAjgDAFgVTodhClN6YTMwZkNKxmDGEGWU5JNkdsDuMzBGQKU+pxY/SyEFMJCgpA6cuUJhgAw6Cb+//8fHB2kWALS0/F/fSchPQQdADQgr5Nhw2yggcSoBdu3//9+FqCeeUBOKTUcwPCf4X9yJ8P6pSCDCRnY9/8Y50mGD8CW7P8EQmpB8gSDFi31buJm4AjLY/T6ic3w/v/rBX4wMGxiYPhvCzGc+q1iv68MP7fM/L+ZC90B/f93SP5g+H8QZjlIHhgKBD1IdLwiLPzv8p7hz87e/xtkYWLd/zfq/WT4fhTI14OJEUsTjFNsBgF9ZvOL4f8joBzYh38Y/l7Epo4YMTJCgBhjiVcz6oDREBjwEAAAwOJpSUqjPhYAAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAX5JREFUWAlj/Njc/J9hIMFAOgBkN9NAeh5k96gDRkNgNARYKMmGXzs7pf78/i3HxsDwnLOm5iE5ZpHlgM9tbaL//v1b9OfXLw+Qpb+A+FNLyz5eLq5QxqKid6Q4hKw0ALR8McP//2DLGRgZ7zEyMv79//+/0+evXyeSYjlILckO+N/fLwDUpwXEX4AWJ/DX1Cj/Z2QsBRkGpO1BNCmA5ChgLCz8ALRADmYJ0OeMn1ta7EA1GuP//49g4sTSJDsA2WCw5a2tM4CWB4CiAYhrkeWJYZMcBciGfm5tLQY6Ig1sOQNDOG919X5keWLYFDkA6HN3kCVAejZvTc1aYixEV0NRFDAyMTUBDZzKwMx8Hd1gYvmUhcD//4oMf/+mMv/7x0WshejqKAoBYFkwDRj83H///AGVRYHohhPDpygEGBkY9gATIDD7M+4lxjKsaihtE/6fOZPs4KdKm5AxPf0bVp8RKUhRFBBpB15low4YDYHREBjwEGCktCTEm8mJkAQABD53sd5+Ls8AAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAhVJREFUWAm9lulOwkAUhaf1WXCNStwIavzhGmOMxrihj+JSTFqsPgpv4Wv4Fmw/JHSuR5Lb2NJhpqWUhEw7c++Z75wuIMQEn9bnZ6nruo8TSAh7kmbr5+dVEjnUbM5k1ckM0G40ZoVl1UiIUvv7+6FwAAoCh4iGzi2iJxxnMpOpCe7nLSHu2TVSmOt5Xo3P04yZAIbuRfT+kUI8Z0khNUDn42MB7m/jLrH5PFK4i8/rzlMDyH6/jsgT+7KkkCikou74/hLcX6vWkcJi1/NuVOtJ86kAaDBwVO5ZHBAv+ILT7GMM0PX9ZUgq3fN2AFxCCto6rjcGkH/uDZ2lScEIAI5WQHzF1LoRKSyjx6jeCADv+7qpe4YzTUELACdliF6ysOmIFFY7nqft0wJkcc+QgHjlY9U4FgBvtjVEeaFq1s4TlduuO7Z/LECAa6/dRFOgS0EJ0Ht/X4f7c42+fploDSkodZQAQRC86dXNKsalkAgA95twf2Ymb1BFtNHyvES9RIA83Yd4RIlPxAhAq9GowP1p2JjXAdEWUhjRHQEQUuZ27ePslpROfC4CgP96VUF0Ei/K6xw3YwVv1oh+BICkrOe1mUpHxlIIAfCsbsP9saoxr3mkUEUKR6wXAmBhateeN+PxfwpDALjfhftDLpj2CLM7SOHgbx9OoDD3bI5TsDquu4ef3C9eKHK0bXvfLvLax83hqXN+AWhR9c/gEiSNAAAAAElFTkSuQmCC\"","import Plain from 'slate-plain-serializer';\n\nconst initialCode = `\n##################\n#                #\n#                #\n#                #\n#                #\n#                #\n#                #\n#    P           #\n#             G  #\n##################\n\nP = Player\n# = Brick\n? = QuestionBrick or Brick\nG = Goomba\nR = GoombaRed\n^ = Spike\n\n[ <HORIZONTAL> Player ] -> [ HORIZONTAL Player ]\n[ <UP> Player | Wall ] -> [ JUMP Player | Wall ]\n[ <ACTION> Player | Wall ] -> [ JUMP Player | Wall ]\n[ Player ] -> [ DOWN Player ]\n[ Goomba ] -> [ DOWN Goomba ]\n\nHORIZONTAL [ Player | Goomba ] -> [ DEAD Player | Goomba ]\nDOWN [ Player | Goomba ] -> [ Player | DEAD Goomba ]\n`;\n\nconst defaultState = {\n  code: initialCode\n}\n\nconst gameReducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'UPDATE_CODE':\n      return {...state, code: action.code}\n    default:\n      return state\n  }\n}\n\nexport default gameReducer","\nexport const TILE_SIZE = 32;\nexport const GROUND_FRICTION = 0.85;\nexport const AIR_FRICTION = 0.85;\nexport const MAX_VELOCITY = 20;\nexport const TOP = 'top';\nexport const BOTTOM = 'bottom';\nexport const LEFT = 'left';\nexport const RIGHT = 'right';","import uniqid from 'uniqid';\nimport {matches, mergeWith, merge, isNumber} from 'lodash-es';\nimport {MAX_VELOCITY, TILE_SIZE} from '../Game/constants.js';\n\nexport const createNewSprite = (name, x, y)=> ({\n  name: name,\n  position: {x, y},\n  velocity: {x: 0, y: 0},\n  maxVelocity: {x: MAX_VELOCITY, y: MAX_VELOCITY},\n  acceleration: {x: 0, y: 0},\n  colliding: {\n    top: [],\n    bottom: [],\n    left: [],\n    right: []\n  },\n  static: false,\n  inputs: {}\n});\nconst trimBrackets = (string)=> string.replace('[', '').replace(']', '')\nconst separateWords = (leftAndRightString)=> (\n  leftAndRightString.map((string)=>\n    trimBrackets(string).trim().split(' ')\n  )\n);\nconst states = {\n  UP: {acceleration: {y: -1}},\n  DOWN: {acceleration: {y: 1}},\n  LEFT: {acceleration: {x: -1}},\n  RIGHT: {acceleration: {x: 1}},\n  FAST_UP: {acceleration: {y: -6}},\n  FAST_DOWN: {acceleration: {y: 6}},\n  FAST_LEFT: {acceleration: {x: -6}},\n  FAST_RIGHT: {acceleration: {x: 6}},\n  SLOW_UP: {acceleration: {y: -0.5}},\n  SLOW_DOWN: {acceleration: {y: 0.5}},\n  SLOW_LEFT: {acceleration: {x: -0.5}},\n  SLOW_RIGHT: {acceleration: {x: 0.5}},\n  JUMP: {velocity: {y: -150}},\n  DEAD: {dead: true},\n  STATIC: {static: true}\n};\n\nconst inputs = {\n  '<UP>': 'up',\n  '<DOWN>': 'down',\n  '<LEFT>': 'left',\n  '<RIGHT>': 'right',\n  '<ACTION>': 'action1',\n  '<ACTION1>': 'action1',\n  '<ACTION2>': 'action2'\n};\n\nconst getOpposite = (direction)=> {\n  const oppositeMappings = {\n    'left': 'right',\n    'right': 'left',\n    'top': 'bottom',\n    'bottom': 'top',\n    'up': 'down',\n    'down': 'up',\n    'forward': 'backward'\n  }\n\n  return oppositeMappings[direction];\n}\n\nconst directionToSide = (direction)=> {\n  const mappings = {\n    'left': 'left',\n    'right': 'right',\n    'down': 'bottom',\n    'up': 'top'\n  }\n\n  return mappings[direction];\n}\n\n// Recursively finds the colliding state\nconst getCollidingForSide = (side, traverseDirection, states, currentIndex)=> {\n  const nextIndex = traverseDirection === 'forward' ? currentIndex + 1 : currentIndex - 1;\n  // outside range\n  if (nextIndex < 0 || nextIndex === states.length) {\n    return;\n  }\n\n  const collidesWith = states[nextIndex];\n  if (!collidesWith) {\n    console.error('Expecting there to always be a state here');\n  }\n\n  let state = [{\n    ...collidesWith\n  }];\n\n  const nextColliding = getCollidingForSide(side, traverseDirection, states, nextIndex);\n  if (nextColliding) {\n    state.colliding = {\n      [side]: nextColliding\n    }  \n  }\n\n  return state;\n}\n\nconst getColliding = (direction, leftStates, leftIndex)=> {\n  // direction refers to the direction the collision rule is applied in.\n  // getCollidingForSide('bottom', 'forward' ... refers to searching for the colliding state for\n  // the bottom side by traversing the ruleString to the right (forward)\n  let colliding = {};\n  const frontSide = directionToSide(direction);\n  const backSide = getOpposite(frontSide);\n  const frontColliding = getCollidingForSide(frontSide, 'forward', leftStates, leftIndex);\n  const backColliding = getCollidingForSide(backSide, 'backward', leftStates, leftIndex);\n\n  if (backColliding) {\n    colliding[backSide] = backColliding;\n  }\n\n  if (frontColliding) {\n    colliding[frontSide] = frontColliding;\n  }\n\n  if (frontColliding || backColliding) {\n    return colliding; \n  }\n  else {\n    return;\n  }\n}\n\n/*\nStarts withObject.keys( ).length > 0 ? colliding : undefined;\n  [ UP Player | Spike ] -> [ DEAD Player | Spike ]\nBreaks up into 2 rules\n  [ UP Player] -> [ DEAD Player]\n  [ Spike ] -> [ Spike ]\nEvaluate both rules into a pair of state mutations\n[\n  {name: \"Player\", acceleration: {x: 1, y: 0}},\n  {name: \"Player\", dead: true}\n]\n[\n  {name: \"Spike\"},\n  {name: \"Spike\"}\n]\n// Finally adds a colliding property to the left side each state mutation\n[\n  {\n    name: \"Player\", acceleration: {x: 1, y: 0},\n    colliding: {\n      top: {name:'Spike'}, bottom: {name:'Spike'},\n      left: {name:'Spike'}, right: {name:'Spike'}\n    }\n  },\n  {name: \"Player\", dead: true}\n]\n[\n  {\n    name: \"Spike\",\n    colliding: {\n      top: {name:'Player'}, bottom: {name:'Player'},\n      left: {name:'Player'}, right: {name:'Player'}\n    }\n  }\n  {name: \"Spike\"}\n]\n*/\nexport const collisionRuleToStateMutations = (ruleString, names)=> {\n  // Get collision direction (first word at the start of the line)\n  const [firstWord] = ruleString.match(/^([A-Z]+)\\b/);\n  const direction = firstWord.toLowerCase();\n\n  // Get the left and right matches\n  const [left, right] = ruleString.split('->');\n  const [leftGroup] = left.match(/\\[.+?\\]/);\n  const [rightGroup] = right.match(/\\[.+?\\]/);\n\n  // leftWords and rightWords can each be arbirary lengths\n  // Consider the left side could be a collision involving 3 parties but on the right side\n  // we only care about the first of those parties.\n  // [ Player | Goomba | Player2 ] -> [ | DEAD Goomba | ]\n\n  // Also consider the left side may involve no collisions, but the right side might\n  // as is the case of mario throwing a fireball\n  // HORIZONTAL [ <ACTION> Mario] -> [ Mario | HORIZONTAL Fireball ]\n  // HORIZONTAL [ <ACTION> Mario] -> [ Mario + HORIZONTAL Fireball ]\n  \n  // const min = Math.min(left.length, right.length);\n  // const max = Math.max(left.length, right.length);\n\n  // // Deal with the simple matches first\n  // for (let i = 0; i < min; i++) {\n\n  // }\n\n  // // These are the extras, the ones that don't have a match on the opposite side\n  // for (let i = min; i < max; i++) {\n  //   // If they exist on the left, but not the right. Then it is assumed the sprite is to remain as it was\n  //   if (left.length > right.length) {\n  //     const oldWords = left[i];\n  //   }\n  //   // But if they exist on the right, but not the left. Then these are new sprites to be spawned.\n  //   else {\n  //     const newWords = right[i];\n  //   }\n  // }\n\n  // <-------- leftWordArrays----->    <--- rightWordArrays -->\n  // <---words--> < ----words----->    <-words-> <---words---->\n  // [ UP Player | Goomba | Brick ] -> [ Player | DEAD Goomba ]\n  const leftWordArrays = leftGroup.split('|') |> separateWords;\n  const rightWordArrays = rightGroup.split('|') |> separateWords;\n\n  let leftStates = [];\n  let rightStates = [];\n\n  // Left\n  // The left side is what the rule is looking to match.\n  // The colliding state should recursively nest colliding states if the rule has multiple collisions\n  for (const words of leftWordArrays) {\n    const state = {\n      ...wordsToState(words, names)\n    }\n\n    leftStates.push(state);\n  }\n\n  const leftStatesWithColliding = leftStates.map((state, index)=> {\n    const colliding = getColliding(direction, leftStates, index);\n\n    if (colliding) {\n      return {\n        ...state,\n        colliding: getColliding(direction, leftStates, index),\n      }\n    }\n    else {\n      return state;\n    }\n  });\n\n  // Right\n  // The right state is any changes to the left state. And includes the creation\n  // of completely new state.\n  let rightIndex = 0;\n  for (const words of rightWordArrays) {\n    const matchingLeft = leftWordArrays[rightIndex];\n    let state;\n    if (matchingLeft) {\n      // If there's a matching left state, then this state is a mutation of that\n      // state. It may be a small change like adding DEAD to a Player.\n      // Eg: [ Mario | Goomba ] -> [ DEAD Mario | Goomba ]\n      state = wordsToState(words, names);\n    }\n    else {\n      // If there is no matching let state, then this is a completely new state.\n      // Eg: the fireball in this rule: [ <ACTION> Mario ] -> [ Mario | Fireball ]\n      const newSprite = createNewSprite('TEMP_NAME', 0, 0);\n      state = {\n        ...newSprite,\n        createNew: {direction}, // indicates to applyStateMutations not to merge this but create new state\n        ...wordsToState(words, names)\n        // I don't think the right side needs the colliding state calculated\n      }\n\n      // Duplicate the leftmost match state as the match for this new state\n      leftStatesWithColliding.push({...leftStates[0]});\n    }\n\n    rightStates.push(state);\n    rightIndex += 1;\n  }\n\n  // State pairs to state mutations\n  return leftStatesWithColliding.map((leftState, index)=> [leftState, rightStates[index]]);\n\n  // const leftStateA = wordsToState(leftWordsA, names);\n  // const leftStateB = leftWordsB\n  //   ? wordsToState(leftWordsB, names)\n  //   : newSprite()\n    \n  // const rightStateA = wordsToState(rightWordsA, names);\n\n  // // User may omit rightWordsB. In which case populate it with leftWordsB\n  // // Eg: [ <ACTION> Player | Ground ] -> [ JUMP Player ]\n  // // Becomes: [ <ACTION> Player | Ground ] -> [ JUMP Player ]\n  // const rightStateB = wordsToState(rightWordsB ? rightWordsB : leftWordsB, names);\n\n  // // Pay close attention to the flipping of A and B for certain variables.\n  // // collidingA is used as the colliding state for spriteB and vice-a-versa\n  // let collidingA = {};\n  // collidingA[getOpposite(directionToSide(direction))] = [{...leftStateA}]\n\n  // let collidingB = {};\n  // collidingB[directionToSide(direction)] = [{...leftStateB}]\n\n  // const pairA = [\n  //   {...leftStateA, colliding: collidingB},\n  //   rightStateA\n  // ];\n  // const pairB = [\n  //   {...leftStateB, colliding: {...collidingA}},\n  //   rightStateB\n  // ];\n\n  // return [pairA, pairB];\n}\n\nconst wordsToState = (words, names)=> {\n  /* Turn those words into arrays of key value objects\n    [\n      [{name: \"Goomba\"}],\n      [{name: \"Goomba\"}, {acceleration: {x: 1}}]},\n      [{name: \"Goomba\"}, {acceleration: {y: 1}}]}\n    ]\n  */\n  const statesArr = words.map((word)=> {\n    if (names[word]) {\n      return ({\n        name: word\n      });\n    }\n    if (inputs[word]) {\n      return ({\n        inputs: {[inputs[word]]: true}\n      });\n    }\n    if (states[word]) {\n      return ({\n        ...states[word]\n      })\n    }\n\n    return {};\n  });\n\n  /* Flatten and merge all the states together into a single state object:\n    {name: \"Goomba\", acceleration: {x: 1, y: 1}}\n  */\n  let resultState = {};\n  for (const stateObj of statesArr) {\n    merge(resultState, stateObj);\n  }\n\n  return resultState;\n};\n\nexport const ruleToStateMutation = (ruleString, names)=> {\n  // First, turn the rule string into an array of words\n  // eg: the ruleString \"[ Goomba ] -> [ RIGHT Goomba ]\"\n  // becomes: [[\"Goomba\"], [\"RIGHT\", \"Goomba\"]]\n  const [leftWords, rightWords] = ruleString.split('->')\n    |> separateWords;\n    \n  const leftState = wordsToState(leftWords, names);\n  const rightState = wordsToState(rightWords, names);\n\n  return [leftState, rightState];\n}\n\nconst addVectors = (vectorA, vectorB)=> ({\n  x: vectorA.x + vectorB.x,\n  y: vectorA.y + vectorB.y\n});\n\nconst getDirectionOffset = (direction)=> {\n  const directionOffsetsMap = {\n    up: {x: 0, y: -TILE_SIZE},\n    down: {x: 0, y: TILE_SIZE},\n    left: {x: -TILE_SIZE, y: 0},\n    right: {x: TILE_SIZE, y: 0}\n  }\n\n  return directionOffsetsMap[direction];\n}\n\nexport const getNewStateToAdd = (sprites, mutations)=> {\n  const newState = [];\n\n  for (const sprite of sprites) {\n    for (const mutation of mutations) {\n      const [left, right] = mutation;\n\n      if (matches(left)(sprite)) {\n        // Add new sprite + give it a unique ID\n        newState.push({\n          ...right,\n          id: uniqid(),\n          position: addVectors(sprite.position, getDirectionOffset(right.createNew.direction)),\n          createNew: undefined\n        });\n      }\n    }\n  }\n\n  return newState;\n}\n\nexport const addNewState = (sprites, newState)=> {\n  return [\n    ...sprites,\n    ...newState\n  ]\n}\n\n// custom merge rules\nconst mergeCustomizer = (objValue, srcValue)=> {\n  if (isNumber(objValue)) {\n    return objValue + srcValue;\n  }\n}\n\nexport const applyStateMutations = (sprite, mutations)=> {\n  if (mutations.length === 0) {\n    return sprite;\n  }\n  \n  let resultState = {...sprite};\n\n  for (const mutation of mutations) {\n    const [left, right] = mutation;\n\n    if (matches(left)(sprite)) {\n      resultState = mergeWith(resultState, right, mergeCustomizer)\n    }\n  }\n\n  return resultState;\n};\n\nexport const isAlive = (sprite)=> !sprite.dead;\nexport const isCreateNewState = (stateMutation)=> {\n  const [, right] = stateMutation;\n  return right.createNew !== undefined;\n};","import {createNewSprite} from './state.js';\nimport {flatten} from 'lodash-es';\nimport {TILE_SIZE} from '../Game/constants.js';\nimport uniqid from 'uniqid';\n\nconst isCollisionRule = (line)=> line.includes('|');\nconst isRule = (line)=> line.includes('->') && !isCollisionRule(line);\nconst isLevel = (line)=> line.match(/#.+#/g)\nexport const isLegend = (line)=> line.includes('=');\n\nexport const parseLegend = (code)=> {\n  let legend = {};\n\n  code.split('\\n')\n    .filter(isLegend)\n    .forEach((line)=> {\n      const [symbol, right] = line.split('=').map((str)=> str.trim());\n      const names = right.split(' or ');\n      // this is a function to allow returning a random name in the case of:\n      // G = Goomba or Tree or Brick\n      legend[symbol] = ()=> {\n        const randIndex = Math.floor(Math.random() * names.length);\n        return names[randIndex];\n      }\n    });\n\n  return legend\n};\n\nconst removeEdges = (lines)=> (\n  lines.slice(1, -1).map((line)=> line.slice(1, -1))\n);\n\nexport const parseLevel = (code)=> (\n  code.split('\\n').filter(isLevel) |> removeEdges\n);\n\nexport const parseNames = (code)=> {\n  const lines = code.split('\\n').filter(isLegend);\n  const names = lines.map((line)=> {\n    const [, right] = line.split(' = ');\n    const words = right.split(' or ');\n    \n    return words;\n  });\n\n  return flatten(names);\n};\n\nexport const getLevelDimensions = (level)=> {\n  const width_in_tiles = level[0].length;\n  const height_in_tiles = level.length;\n  \n  return [width_in_tiles, height_in_tiles];\n}\n\nexport const parseSprites = (level, legend)=> {\n  const sprites = [];\n  level.map((line, row)=> line.split('').forEach((char, col)=> {\n    const getName = legend[char];\n    if (getName && getName() !== 'Empty') {\n      const x = col * TILE_SIZE;\n      const y = row * TILE_SIZE;\n      sprites.push(\n        {\n          id: uniqid(),\n          ...createNewSprite(getName(), x, y)\n        }\n      );\n    }\n  }));\n\n  return sprites;\n};\n\nconst collisionExpandMappings = {\n  ALL: ['LEFT', 'RIGHT', 'UP', 'DOWN'],\n  HORIZONTAL: ['LEFT', 'RIGHT'],\n  VERTICAL: ['UP', 'DOWN']\n}\n\nconst regularExpandMappings = {\n  HORIZONTAL: ['LEFT', 'RIGHT'],\n  VERTICAL: ['UP', 'DOWN']\n}\n\n// Takes a single rule and returns an array with (potentially) multiple rules\n// Eg: Rules starting with HORIZONTAL become both LEFT and RIGHT rules\nconst expandRegularRule = (line)=> {\n  let expandedLines = [];\n\n  for (const [key, words] of Object.entries(regularExpandMappings)) {\n    if (line.includes(`<${key}> `) || line.includes(`${key} `)) {\n      for (const word of words) {\n        const expanded = line\n          // replaces either <LEFT> or LEFT\n          // this would be better swapped for some equivalant that replaces\n          // all occurances of a word\n          .replace(`<${key}> `, `<${word}> `)\n          .replace(`${key} `, `${word} `)\n  \n        expandedLines.push(expanded);\n      }\n    }\n  }\n\n  return expandedLines.length > 0 ? expandedLines : [line]\n}\n\n// Takes a single collision rule and returns an array with (potentially) multiple rules\n// Eg: [ Player | Goomba ] -> [ DEAD Player | Goomba ]\n// becomes\n// UP [ Player | Goomba ] -> [ DEAD Player | Goomba ]\n// DOWN [ Player | Goomba ] -> [ DEAD Player | Goomba ]\n// Etc...\nconst expandCollisionRule = (line)=> {\n  let expandedLines = [];\n\n  // If no direction given, then use 'ALL'. Otherwise use the given direction ('UP', 'DOWN', etc)\n  const [firstWord] = line.split('[');\n  \n  let appendedLine = line;\n  if (firstWord === '') {\n    appendedLine = line.replace('[', 'ALL [');\n  }\n  \n  for (const [key, directions] of Object.entries(collisionExpandMappings)) {\n    if (appendedLine.includes(`${key} `)) {\n      for (const direction of directions) {\n        const expanded = appendedLine\n          .replace(`${key} `, `${direction} `)\n\n        expandedLines.push(expanded);\n      }\n    }\n  }\n\n  return expandedLines.length > 0 ? expandedLines : [line]\n}\n\nexport const parseRules = (code)=> {\n  const regularRules = code.split('\\n').filter(isRule);  \n  const expandedRegularRules = flatten(\n    regularRules.map((line)=> expandRegularRule(line))\n  );\n  \n  const collisionRules = code.split('\\n').filter(isCollisionRule);\n  const expandedCollisionRules = flatten(\n    collisionRules.map((line)=> expandCollisionRule(line))\n  );\n  // const uniqueCollisionRules = removeDuplicateRules(expandedCollisionRules);\n\n  return [\n    expandedRegularRules,\n    expandedCollisionRules\n  ]\n};","import {\n  TILE_SIZE, GROUND_FRICTION, AIR_FRICTION,\n  TOP, BOTTOM, LEFT, RIGHT\n} from './constants.js'\n\nexport const roundToPixels = (sprite)=> ({\n  ...sprite,\n  position: {\n    x: Math.round(sprite.position.x),\n    y: Math.round(sprite.position.y),\n  }\n});\n\nconst getEdges = (sprite)=> ({\n  top: sprite.position.y,\n  bottom: sprite.position.y + TILE_SIZE,\n  left: sprite.position.x,\n  right: sprite.position.x + TILE_SIZE\n});\n\nconst isOverlapping = (spriteA, spriteB)=> {\n  const a = getEdges(spriteA);\n  const b = getEdges(spriteB);\n  \n  return (\n    a.bottom > b.top &&\n    a.top < b.bottom &&\n    a.right > b.left &&\n    a.left < b.right\n  );\n};\n\nconst getPointsForSide = (side, sprite)=> {\n  // INSET is to prevent situations such as both TOP and LEFT/RIGHT colliding when 2 sprites are standing\n  // next to each other.\n  // It's not ideal because it means you do things like stand on a sprite just on the very outmost edge\n  // without triggering any UP DOWN collisions.\n  const INSET = 5;\n\n  if (side === LEFT) {\n    return [\n      {x: sprite.position.x, y: sprite.position.y + INSET},\n      {x: sprite.position.x, y: sprite.position.y + TILE_SIZE - INSET}\n    ]\n  }\n  if (side === RIGHT) {\n    return [\n      {x: sprite.position.x + TILE_SIZE, y: sprite.position.y + INSET},\n      {x: sprite.position.x + TILE_SIZE, y: sprite.position.y + TILE_SIZE - INSET}\n    ]\n  }\n  if (side === TOP) {\n    return [\n      {x: sprite.position.x + INSET, y: sprite.position.y},\n      {x: sprite.position.x + TILE_SIZE - INSET, y: sprite.position.y}\n    ]\n  }\n  if (side === BOTTOM) {\n    return [\n      {x: sprite.position.x + INSET, y: sprite.position.y + TILE_SIZE},\n      {x: sprite.position.x + TILE_SIZE - INSET, y: sprite.position.y + TILE_SIZE}\n    ]\n  }\n}\n\nconst overlapsPoint = (point, spriteB, padding = 0)=> {\n  const {x, y} = point;\n  const {top, bottom, left, right} = getEdges(spriteB);\n  return (\n    y > top - padding &&\n    y < bottom + padding &&\n    x > left - padding &&\n    x < right + padding\n  );\n}\n\nconst overlapsSide = (side, spriteA, spriteB)=> {\n  const points = getPointsForSide(side, spriteA);\n\n  for (const point of points) {\n    if (overlapsPoint(point, spriteB, 1)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst getCollidedEdges = (spriteA, spriteB)=> {\n  const prevEdgesA = getEdges({position: {...spriteA.prevPosition}});\n  const prevEdgesB = getEdges({position: {...spriteB.prevPosition}});\n  const collidedEdges = {top: false, bottom: false, left: false, right: false};\n\n  // by checking if an edge was not overlapping last frame but is this frame\n  // we can see which edge is colliding\n  if (prevEdgesA.top >= prevEdgesB.bottom) {\n    collidedEdges[TOP] = true;\n  }\n  else if (prevEdgesA.bottom <= prevEdgesB.top) {\n    collidedEdges[BOTTOM] = true;\n  }\n\n  if (prevEdgesA.left >= prevEdgesB.right) {\n    collidedEdges[LEFT] = true;\n  }\n  else if (prevEdgesA.right <= prevEdgesB.left) {\n    collidedEdges[RIGHT] = true;\n  }\n\n  return collidedEdges;\n}\n\nconst getAxisFromEdge = (edge)=> {\n  const edgeAxisMap = {\n    left: 'x',\n    right: 'x',\n    top: 'y',\n    bottom: 'y'\n  };\n\n  return edgeAxisMap[edge];\n}\n\nconst getSeparatedState = (edgeA, spriteA, spriteB)=> {\n  const edgesB = getEdges(spriteB);\n  const velocity = {...spriteA.velocity, [getAxisFromEdge(edgeA)]: 0};\n\n  let position = {...spriteA.position};\n  if (edgeA === TOP) {\n    position.y = edgesB[BOTTOM];\n  }\n  else if (edgeA === BOTTOM) {\n    position.y = edgesB[TOP] - TILE_SIZE;\n  }\n  else if (edgeA === LEFT) {\n    position.x = edgesB[RIGHT];\n  }\n  else if (edgeA === RIGHT) {\n    position.x = edgesB[LEFT] - TILE_SIZE;\n  }\n\n  return {position, velocity};\n}\n\nexport const updateSpriteCollidingState = (spriteA, sprites, width, height)=> {\n  if (spriteA.static) {\n    return spriteA;\n  }\n\n  let colliding = {...spriteA.colliding};\n\n  // sprites\n  for (const spriteB of sprites) {\n    if (spriteA.id === spriteB.id) {\n      continue;\n    }\n\n    for (const edge of [TOP, BOTTOM, LEFT, RIGHT]) {\n      if (overlapsSide(edge, spriteA, spriteB)) {\n        colliding[edge].push({name: spriteB.name});\n      }\n    }\n  }\n\n  // walls\n  const padding = 1;\n  if (spriteA.position.x < 0 + padding) {\n    colliding[LEFT].push({name: 'Wall'});\n  }\n  if (spriteA.position.x > width - TILE_SIZE - padding) {\n    colliding[RIGHT].push({name: 'Wall'});\n  }\n  if (spriteA.position.y < 0 + padding) {\n    colliding[TOP].push({name: 'Wall'});\n  }\n  if (spriteA.position.y > height - TILE_SIZE - padding) {\n    colliding[BOTTOM].push({name: 'Wall'});\n  }\n\n  return {...spriteA, colliding};\n};\n\nexport const applySpriteCollisions = (spriteA, sprites)=> {\n  if (spriteA.static) {\n    return spriteA;\n  }\n\n  for (const spriteB of sprites) {\n    if (spriteA.id === spriteB.id) {\n      continue;\n    }\n\n    if (isOverlapping(spriteA, spriteB)) {    \n      const collidedEdges = getCollidedEdges(spriteA, spriteB);\n      let newSpriteA = {...spriteA};\n      \n      if (collidedEdges[TOP]) {\n        newSpriteA = {\n          ...newSpriteA,\n          ...getSeparatedState(TOP, spriteA, spriteB)\n        }\n      }\n      else if (collidedEdges[BOTTOM]) {\n        newSpriteA = {\n          ...newSpriteA,\n          ...getSeparatedState(BOTTOM, spriteA, spriteB)\n        }\n      }\n\n      // Check if overlap has been resolved before resolving horizontal collisions\n      // This is a cheap trick to prevent sprite from catching on the corners\n      // of adjacent tiles (vertical is resolved first & the horizontal is avoided)\n      if (isOverlapping(newSpriteA, spriteB)) {\n        if (collidedEdges[LEFT]) {\n          newSpriteA = {\n            ...newSpriteA,\n            ...getSeparatedState(LEFT, spriteA, spriteB)\n          }\n        }\n        else if (collidedEdges[RIGHT]) {\n          newSpriteA = {\n            ...newSpriteA,\n            ...getSeparatedState(RIGHT, spriteA, spriteB)\n          }\n        }\n      }\n      \n      return newSpriteA;\n    }\n  }\n\n  return spriteA;\n};\n\nexport const applyWallCollisions = (sprite, width, height)=> {\n  if (sprite.static) {\n    return sprite;\n  }\n\n  const newPosition = {...sprite.position};\n\n  if (sprite.position.y > height - TILE_SIZE) {\n    newPosition.y = height - TILE_SIZE;\n  }\n\n  if (sprite.position.y < 0) {\n    newPosition.y = 0;\n  }\n\n  if (sprite.position.x > width - TILE_SIZE) {\n    newPosition.x = width - TILE_SIZE;\n  }\n\n  if (sprite.position.x < 0) {\n    newPosition.x = 0;\n  }\n  \n  return {\n    ...sprite,\n    position: newPosition\n  }\n};\n\nexport const storePreviousPosition = (sprite)=> ({\n  ...sprite,\n  prevPosition: {...sprite.position}\n});\n\nexport const applyAcceleration = (sprite)=> {\n  const {velocity, maxVelocity, acceleration} = sprite;\n  return {\n    ...sprite,\n    velocity: {\n      x: Math.max(Math.min(velocity.x + acceleration.x, maxVelocity.x), -maxVelocity.x),\n      y: Math.max(Math.min(velocity.y + acceleration.y, maxVelocity.y), -maxVelocity.y)\n    },\n    acceleration: {x: 0, y: 0}\n  }\n};\n\nexport const applyVelocity = (sprite)=> ({\n  ...sprite,\n  position: {\n    x: sprite.position.x + sprite.velocity.x,\n    y: sprite.position.y + sprite.velocity.y\n  }\n});\n\nexport const resetColliding = (sprite)=> ({\n  ...sprite,\n  colliding: {top: [], bottom: [], left: [], right: []},\n\n});\n\nexport const applyFriction = (sprite)=> ({\n  ...sprite,\n  velocity: {\n    x: (sprite.colliding.top.length > 0 || sprite.colliding.bottom.length > 0)\n      ? sprite.velocity.x * GROUND_FRICTION\n      : sprite.velocity.x * AIR_FRICTION,\n    y: (sprite.colliding.left.length > 0 || sprite.colliding.right.length > 0)\n      ? sprite.velocity.y * GROUND_FRICTION\n      : sprite.velocity.y * AIR_FRICTION,\n  }\n});","import {flatten} from 'lodash-es';\nimport {parseRules, parseSprites, parseLegend, parseLevel, parseNames,\n  getLevelDimensions} from '../util/parse.js';\nimport {ruleToStateMutation, collisionRuleToStateMutations, applyStateMutations,\n  isAlive, isCreateNewState, getNewStateToAdd, addNewState} from '../util/state.js'\nimport {storePreviousPosition, applyAcceleration, applyVelocity, applyFriction,\n  updateSpriteCollidingState, applySpriteCollisions, roundToPixels,\n  applyWallCollisions, resetColliding\n} from './physics';\nimport {TILE_SIZE} from '../Game/constants.js'\n\nconst defaultState = {\n  sprites: [],\n  legend: {},\n  names: {},\n  rules: [],\n  stateMutations: [],\n  width_in_tiles: 0,\n  height_in_tiles: 0,\n  active: false,\n  theme: 'dark',\n  debug: false,\n  imageMap: {},\n  images: ['player', 'brick', 'questionbrick', 'spike', 'goomba', 'goombared']\n};\n\nconst arrayToObject = (array) =>\n   array.reduce((obj, item) => {\n     obj[item] = true\n     return obj\n   }, {})\n\nconst removeComments = (code)=>\n  code.split('\\n').filter(\n    (line)=> !line.includes('//')\n  ).join('\\n')\n\nconst gameReducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'SET_ACTIVE':\n      return {\n        ...state,\n        active: action.active\n      }\n\n    case 'TOGGLE_DEBUG':\n      return {\n        ...state,\n        debug: !state.debug\n      }\n    \n    case 'SELECT_IMAGE':\n      const imageMap = {...state.imageMap}\n      const {variableName, imageName} = action\n      imageMap[variableName] = imageName;\n      return {\n        ...state,\n        imageMap\n      }\n    \n    case 'COMPILE':\n      try {\n        const code = removeComments(action.code);\n        const level = parseLevel(code);\n        const legend = parseLegend(code);\n        const sprites = parseSprites(level, legend);\n    \n      // Names is the legend mapped to have the values as keys. Used for fast name lookup.\n      // this used to use the legend before the random features were added.\n      // For this to work though, names needs to include all possible names, including those that might not be rendered onto\n      // the map the first time it is loaded. I suppose later on this should also include things spawned within rules that may\n      // not also appear in the legend.\n      // Ideally, I could refactor out this names object entirely. It seems like that should be possible.\n      const namesArr = parseNames(code);\n      const names = arrayToObject(namesArr);\n      \n      const imageMap = {...state.imageMap};\n      for (const name of namesArr) {\n        if (!imageMap[name]) {\n          imageMap[name] = state.images[name] ? name.toLowerCase() : 'player';\n        }\n      }\n\n        // A rule consists of a before and an after state referred to as a state mutation\n        const [rules, collisionRules] = parseRules(code);\n        const stateMutations = rules.map((rule)=> ruleToStateMutation(rule, names)); // [leftState, rightState]\n\n        // collisionRules are a bit more complicated\n        const collisionStateMutationPairs = collisionRules.map(\n          (rule)=> collisionRuleToStateMutations(rule, names)\n        );\n        const collisionStateMutations = flatten(collisionStateMutationPairs);\n        \n        // separate the collisionStateMutations into 2 groups: \n          // those that will spawn new state\n          // and those that will modify existing state\n        const collisionStateMutationsCreate = collisionStateMutations.filter(isCreateNewState);\n        const collisionStateMutationsModify = collisionStateMutations.filter((e)=> !isCreateNewState(e));\n\n        const [width_in_tiles, height_in_tiles] = getLevelDimensions(level);\n\n        return {\n          ...defaultState,\n          sprites,\n          legend,\n          rules: [...rules, ...collisionRules],\n          stateMutations,\n          collisionStateMutationsCreate,\n          collisionStateMutationsModify,\n          width: width_in_tiles * TILE_SIZE,\n          height: height_in_tiles * TILE_SIZE,\n          names,\n          imageMap\n        }\n      }\n      catch(err) {\n        console.error(err);\n        return {\n          ...defaultState,\n          error: 'Compilation error 😞'\n        }\n      }\n\n    case 'UPDATE':\n      const previousState = {...state};\n      const stateToAdd = getNewStateToAdd(state.sprites, state.collisionStateMutationsCreate);\n      return {\n          ...state,\n          sprites: state.sprites.filter(isAlive)\n              |> ((sprites)=> addNewState(sprites, stateToAdd))\n              |> ((sprites)=> sprites.map(resetColliding))\n              |> ((sprites)=> sprites.map((sprite)=> updateSpriteCollidingState(\n                sprite, state.sprites, state.width, state.height\n              )))\n              |> ((sprites)=> sprites.map(storePreviousPosition))\n              |> ((sprites)=> sprites.map((sprite)=> applyStateMutations(sprite, state.stateMutations)))\n              |> ((sprites)=> sprites.map((sprite)=> applyStateMutations(sprite, state.collisionStateMutationsModify)))\n              |> ((sprites)=> sprites.map(applyFriction))\n              |> ((sprites)=> sprites.map(applyAcceleration))\n              |> ((sprites)=> sprites.map(applyVelocity))\n              |> ((sprites)=> sprites.map((sprite)=> applySpriteCollisions(sprite, state.sprites, previousState)))\n              |> ((sprites)=> sprites.map((sprite)=> applySpriteCollisions(sprite, state.sprites, previousState)))\n              |> ((sprites)=> sprites.map((sprite)=> applySpriteCollisions(sprite, state.sprites, previousState)))\n              // |> ((sprites)=> sprites.map((sprite)=> applySpriteCollisionsCrossMethod(sprite, state.sprites, previousState)))\n              |> ((sprites)=> sprites.map((sprite)=> applyWallCollisions(sprite, state.width, state.height)))\n              |> ((sprites)=> sprites.map(roundToPixels))\n      }\n    case 'SET_INPUT':\n    return {\n      ...state,\n      sprites: state.sprites.map(\n        (sprite)=> ({...sprite, inputs: {...sprite.inputs, [action.input]: true}})\n      )\n    };\n\n    case 'TOGGLE_THEME':\n      return {\n        ...state,\n        theme: state.theme === 'light' ? 'dark' : 'light'\n      };\n\n    case 'CANCEL_INPUT':\n      return {\n        ...state,\n        sprites: state.sprites.map(\n          (sprite)=> {\n            const newInputs = {...sprite.inputs};\n            newInputs[action.input] = undefined;\n            return {...sprite, inputs: newInputs}\n          }\n        )\n      };\n\n    default:\n      return state\n  }\n}\n\nexport default gameReducer","import {combineReducers} from 'redux';\nimport codeReducer from './Code/reducer.js';\nimport gameReducer from './Game/reducer.js';\n\nexport default combineReducers({\n  code: codeReducer,\n  game: gameReducer\n})\n","import React from 'react';\nimport './debug.scss';\n\nexport const DebugColliding = ({sprite})=> (\n  <div className='debug-colliding'>\n    {Object.entries(sprite.colliding).map(([key, value], index)=> \n      <p className={`number ${key} ${value.length > 0 && 'active'}`}>\n        {value.length}\n      </p>\n    )}\n  </div>\n)","import React from 'react';\nimport {DebugColliding} from '../debug/DebugColliding.js';\nimport './Sprite.css';\n\nconst getPositionStyle = (x, y)=> ({\n  position: 'relative', left: x, top: y\n});\n\nconst Sprite = ({x, y, img, sprite, debug})=> (\n  <div className=\"sprite\" style={getPositionStyle(x, y)}>\n    <img src={require(`./images/${img}.png`)} alt='' />\n    {debug && <DebugColliding sprite={sprite} />}\n  </div>\n);\n\nexport default Sprite;\n","import React from 'react';\nimport Sprite from './Sprite.js';\n\nconst Game = ({sprites, width, height, imageMap, error, debug})=> (\n  <div className='stage' style={{width, height}}>\n    {error && <p className='error' >{error}</p>}\n    {sprites.map((sprite)=>\n      <Sprite\n        key={sprite.id}\n        x={sprite.position.x}\n        y={sprite.position.y}\n        img={imageMap[sprite.name] || 'player'}\n        sprite={sprite} // used for debug visualisation\n        debug={debug}\n      />\n    )}\n  </div>\n);\n\nexport default Game","import React, {useEffect} from 'react';\nimport {update} from './actions.js';\nimport {connect} from 'react-redux'\n\nconst Loop = ({onTimeChange})=> {\n  // recursively calls itself once per frame\n  let request;\n  const advanceFrame = ()=> {\n    onTimeChange();\n    request = requestAnimationFrame(()=> advanceFrame());\n  }\n\n  useEffect(() => {\n    request = requestAnimationFrame(()=> advanceFrame());\n    return function cleanup() {\n      cancelAnimationFrame(request);\n    }\n  }, []);\n\n  return <p></p>;\n};\n\nconst mapDispatchToProps = (dispatch)=> ({\n  onTimeChange: ()=> {\n    dispatch(update());\n  }\n});\n\nexport default connect(\n  null,\n  mapDispatchToProps\n)(Loop);\n","\nexport const update = ()=> ({\n  type: 'UPDATE'\n})\n\nexport const updateSprite = (sprite)=> ({\n  type: 'UPDATE_SPRITE',\n  sprite\n})\n\nexport const toggleDebug = (active)=> ({\n  type: 'TOGGLE_DEBUG',\n  active\n})\n\n","\nexport const updateCode = (code)=> ({\n  type: 'UPDATE_CODE',\n  code\n})\n\nexport const compile = (code)=> ({\n  type: 'COMPILE',\n  code\n})\n\nexport const setActive = (active)=> ({\n  type: 'SET_ACTIVE', active\n})\n","import React from 'react';\nimport {connect} from 'react-redux';\nimport Tooltip from '@material-ui/core/Tooltip';\n\nconst ImagePicker = ({variableName, imageMap, images, onSelect})=> {  \n  // imageMap will be an empty object before <Code /> has been loaded\n  // this protects against that case\n  if (Object.keys(imageMap).length === 0) {\n    return null;\n  }\n\n  const image = imageMap[variableName] ? imageMap[variableName] : 'player';\n\n  return (\n    <Tooltip\n      interactive\n      title={\n        <div className='tooltip-content'>\n          {images.map((name)=> (\n            <img\n              key={name}\n              alt=''\n              src={require(`../Game/images/${name}.png`)}\n              onClick={()=> onSelect(variableName, name)}\n            />\n          ))}\n        </div>\n      }\n    >\n      <img className='code-sprite'\n        alt=''\n        src={require(`../Game/images/${image}.png`)}\n      />\n    </Tooltip>\n  )\n};\n\nconst mapStateToProps = ({game})=> ({\n  imageMap: game.imageMap,\n  images: game.images\n})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  onSelect: (variableName, imageName)=> {\n    dispatch({\n      type: 'SELECT_IMAGE',\n      variableName,\n      imageName\n    });\n  }\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ImagePicker);\n","import React, {useEffect} from 'react';\nimport {updateCode, compile} from './actions.js';\nimport {connect} from 'react-redux';\nimport Prism from 'prismjs';\nimport {Editor} from 'slate-react';\nimport Plain from 'slate-plain-serializer';\nimport ImagePicker from '../ImagePicker/ImagePicker.js';\n\nconst makeGrammar = ()=> {\n  return {\n    comment: /\\/\\/.*/,\n    variable: {\n      pattern: new RegExp(' = ([A-Z]+)', 'i'),\n    }\n  }\n}\n\nconst grammar = makeGrammar();\n\nconst onKeyDown = (event, editor, next)=> {\n  if (event.ctrlKey && event.key === 'b') {\n    event.preventDefault()\n    console.log('add bold')\n    editor.addMark('bold')\n  } else {\n    return next()\n  }\n}\n\nconst getContent = (token)=> {\n  if (typeof token == 'string') {\n    return token\n  } else if (typeof token.content == 'string') {\n    return token.content\n  } else {\n    return token.content.map(getContent).join('')\n  }\n}\n\nconst decorateNode = (node, editor, next)=> {\n  const others = next() || []\n  const texts = node.getTexts().toArray()\n  const string = texts.map(t => t.text).join('\\n')\n\n  if (texts.length !== 1) {\n    return others;\n  }\n\n  const tokens = Prism.tokenize(string, grammar)\n  const decorations = []\n  let startText = texts.shift()\n  let endText = startText\n  let startOffset = 0\n  let endOffset = 0\n  let start = 0\n\n  for (const token of tokens) {\n    startText = endText\n    startOffset = endOffset\n\n    const content = getContent(token)\n    const newlines = content.split('\\n').length - 1\n    const length = content.length - newlines\n    const end = start + length\n\n    let available = startText.text.length - startOffset\n    let remaining = length\n\n    endOffset = startOffset + remaining\n\n    while (available < remaining && texts.length > 0) {\n      endText = texts.shift()\n      remaining = length - available\n      available = endText.text.length\n      endOffset = remaining\n    }\n\n    if (typeof token != 'string') {\n      const dec = {\n        anchor: {\n          key: startText.key,\n          offset: startOffset,\n        },\n        focus: {\n          key: endText.key,\n          offset: endOffset,\n        },\n        mark: {\n          type: token.type,\n        },\n      }\n\n      decorations.push(dec)\n    }\n\n    start = end\n  }\n\n  return [...others, ...decorations]\n}\n\nconst renderMark = (props, editor, next, imageMap) => {\n  const { children, attributes, node } = props\n\n  switch (props.mark.type) {\n    case 'variable':\n      const [, right] = node.text.split('=').map((str)=> str.trim())\n      const [firstName,] = right.split(' or ')\n\n      return <span {...attributes}>\n        {children}\n        <ImagePicker variableName={firstName} />\n      </span>\n    case 'comment':\n      return (\n        <span {...attributes} style={{ opacity: '0.33' }}>\n          {children}\n        </span>\n      )\n    case 'keyword':\n      return (\n        <span {...attributes} style={{ fontWeight: 'bold' }}>\n          {children}\n        </span>\n      )\n    default:\n      return next()\n  }\n}\n\nconst Code = ({code, imageMap, onUpdateCode, onCompile})=> {\n  // manually trigger code change on first load\n  useEffect(() => {\n    onCompile(code);\n  }, []);\n\n  return <Editor\n    className={'code'}\n    defaultValue={Plain.deserialize(code)}\n    onChange={onUpdateCode}\n    onKeyDown={onKeyDown}\n    decorateNode={decorateNode}\n    renderMark={(props, editor, next)=> renderMark(props, editor, next, imageMap)}\n  />\n};\n\nconst mapStateToProps = ({code, game})=> ({\n  code: code.code,\n  width: game.width, \n  height: game.height,\n  imageMap: game.imageMap\n})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  onUpdateCode: ({value})=> {\n    dispatch(updateCode(Plain.serialize(value)));\n  },\n  onCompile: (code)=> {\n    dispatch(compile(code));\n  }\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Code);\n","import React from 'react';\nimport {connect} from 'react-redux'\nimport {HotKeys} from 'react-hotkeys';\nimport Game from '../Game/Game.js';\nimport Loop from '../Game/Loop.js';\nimport Code from '../Code/Code.js';\nimport {compile, setActive} from '../Code/actions';\nimport {toggleDebug} from '../Game/actions.js';\nimport {setInput, cancelInput, toggleTheme} from './actions.js';\nimport CustomProperties from 'react-custom-properties';\nimport './App.scss';\n\nconst darkColors = {\n  primary: '#F1A0A0',\n  secondary: '#87FFAE',\n  dark: '#000000',\n  light: '#FDF6E2'\n}\n\nconst lightColors = {\n  primary: '#43153F',\n  secondary: '#87FFAE',\n  dark: '#FDF6E2',\n  light: '#FFFFFF'\n}\n\nconst keyMap = {\n  'up': {sequence: 'up', action: 'keydown'},\n  'down': {sequence: 'down', action: 'keydown'},\n  'left': {sequence: 'left', action: 'keydown'},\n  'right': {sequence: 'right', action: 'keydown'},\n  'action1': {sequence: 'x', action: 'keydown'},\n  'action2': {sequence: 'z', action: 'keydown'},\n\n  'cancel_up': {sequence: 'up', action: 'keyup'},\n  'cancel_down': {sequence: 'down', action: 'keyup'},\n  'cancel_left': {sequence: 'left', action: 'keyup'},\n  'cancel_right': {sequence: 'right', action: 'keyup'},\n  'cancel_action1': {sequence: 'x', action: 'keyup'},\n  'cancel_action2': {sequence: 'z', action: 'keyup'},\n};\n\nconst handlers = (onSetInput, onCancelInput, onReset, onRun, onToggleDebug, isGameActive)=> ({\n  'up': ()=> onSetInput('up'),\n  'down': ()=> onSetInput('down'),\n  'left': ()=> onSetInput('left'),\n  'right': ()=> onSetInput('right'),\n  'action1': ()=> onSetInput('action1'),\n  'action2': ()=> onSetInput('action2'),\n  'r': ()=> onReset(),\n  'd': ()=> onToggleDebug(),\n  'space': ()=> onRun(!isGameActive),\n\n  'cancel_up': ()=> onCancelInput('up'),\n  'cancel_down': ()=> onCancelInput('down'),\n  'cancel_left': ()=> onCancelInput('left'),\n  'cancel_right': ()=> onCancelInput('right'),\n  'cancel_action1': ()=> onCancelInput('action1'),\n  'cancel_action2': ()=> onCancelInput('action2'),\n});\n\nconst App = ({\n    code, compile, theme, sprites, imageMap, width, height, debug, error,\n    isGameActive, setGameActive, onToggleDebug, onSetInput, onCancelInput, onToggleTheme\n})=> {\n  const colors = theme === 'light' ? lightColors : darkColors;\n  \n  return (\n    <CustomProperties className=\"custom-properties-container\" properties={{\n      '--primary-color': colors.primary,\n      '--secondary-color': colors.secondary,\n      '--dark-color': colors.dark,\n      '--light-color': colors.light,\n      '--hover-color': `${colors.primary}22`  // 22 is is the alpha in hex\n    }}>\n      <div className=\"main\">\n        <div className=\"left\">\n          <header>\n            <h1>micro gg</h1>\n            <button className='primary' onClick={()=> onToggleTheme()}>\n            {theme === 'dark' ? 'light' : 'dark'}\n            </button>\n          </header>\n          <Code imageMap={imageMap} />\n        </div>\n        <HotKeys\n          handlers={handlers(\n            onSetInput,\n            onCancelInput,\n            ()=> compile(code),\n            (active)=> setGameActive(active),\n            ()=> onToggleDebug(),\n            isGameActive\n          )}\n          keyMap={keyMap}\n        >\n          <div className=\"right\">\n            <header>\n              <button className='primary' onClick={()=> compile(code)}>compile</button>\n              <button className='secondary' onClick={()=> setGameActive(!isGameActive)}>\n                {isGameActive ? 'pause' : 'run'}\n              </button>\n              {isGameActive && <Loop />}\n            </header>\n            <div className=\"game-container\">\n              <Game\n              sprites={sprites}\n              imageMap={imageMap}\n              width={width}\n              height={height}\n              debug={debug}\n              error={error}\n            />\n          </div>\n          </div>\n        </HotKeys>\n      </div>\n    </CustomProperties>\n  );\n};\n\nconst mapStateToProps = ({code, game})=> ({\n  code: code.code,\n  theme: game.theme,\n  isGameActive: game.active,\n  sprites: game.sprites,\n  imageMap: game.imageMap,\n  width: game.width,\n  height: game.height,\n  debug: game.debug,\n  error: game.error\n})\n\nconst mapDispatchToProps = (dispatch)=> ({\n  compile: (code)=> {\n    dispatch(compile(code));\n  },\n  setGameActive: (active)=> {\n    dispatch(setActive(active));\n  },\n  onSetInput: (input)=> {\n    dispatch(setInput(input));\n  },\n  onCancelInput: (input)=> {\n    dispatch(cancelInput(input));\n  },\n  onToggleDebug: ()=> {\n    dispatch(toggleDebug());\n  },\n  onToggleTheme: ()=> {\n    dispatch(toggleTheme());\n  }\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(App);\n","\nexport const setInput = (input)=> ({\n  type: 'SET_INPUT',\n  input\n})\n\nexport const cancelInput = (input)=> ({\n  type: 'CANCEL_INPUT',\n  input\n})\n\nexport const toggleTheme = ()=> ({\n  type: 'TOGGLE_THEME'\n})","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {Provider} from 'react-redux'\nimport {createStore} from 'redux'\nimport { persistStore, persistReducer } from 'redux-persist'\nimport { PersistGate } from 'redux-persist/integration/react'\nimport storage from 'redux-persist/lib/storage'\nimport rootReducers from './reducers'\nimport './index.css';\nimport './fonts/FiraCode/fira_code.css';\nimport App from './App/App.js';\n\nconst persistConfig = {\n  key: 'root',\n  storage,\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducers);\n\nconst store = createStore(\n  persistedReducer, /* preloadedState, */\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n );\n\nconst persistor = persistStore(store);\n// persistor.purge();\n\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate loading={null} persistor={persistor}>\n      <App />\n    </PersistGate>\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}